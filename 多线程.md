# 线程
```python
import threading

def get_web(name):
    print('get web according',name)

if __name__ == '__main__':
    #创建两个子线程，target为函数引用
    t1 = threading.Thread(target=get_web,args=('baidu',))
    t2 = threading.Thread(target=get_web,args=('tengxun',))


    #默认情况下，主线程会等待所有子线程执行结束
    #setDaemon方法 设置守护进程,再start之前
    #即主线程一旦结束，所有子线程没有运行完也全部结束
    t1.setDaemon(True)
    t2.setDaemon(True)

    #启动线程
    t1.start()
    t2.start()

    #join方法：让子线程阻塞主线程，在start之后
    #主线程会等待使用了join方法的子线程结束后再往下进行
    t1.join()
    t2.join()

    print('程序运行结束')
```

# 锁
只有拿到锁的线程才能对进程的共享资源进行操作

## GIL（全局 解释器 锁）
只有拿到GIL的线程才能执行pyhon代码，所以实际上任何时间点只有一个线程在运行

- 线程在执行IO时会主动放弃GIL
- 线程在执行了100个字节码后会主动放弃GIL
- 要GIL和Threading模块的锁配合使用

### 不加锁
```python
import threading

#余额
num = 0

#存款
def deposit():
    global num
    for i in range(10000000):
        num = num + 1
#取款
def withdraw():
    global num
    for i in range(10000000):
        num = num - 1


if __name__ == '__main__':
    #创建两个子线程
    t1 = threading.Thread(target=deposit)
    t2 = threading.Thread(target=withdraw)

    #启动线程
    t1.start()
    t2.start()

    #join方法：让子线程阻塞主线程，
    #主线程会等待使用了join方法的子线程结束后再往下进行
    t1.join()
    t2.join()

    print(num)   #不加锁，结果不会是0
```

### 加锁
```python
import threading

num = 0
#加锁
lock = threading.Lock()

def deposit():
    global num
    for i in range(10000000):
        #获取锁
        lock.acquire()
        num = num + 1
        #释放锁
        lock.release()
        
#或者用with上下文管理，结束之后自动释放锁
def deposit_with():
    global num
    for i in range(10000000):
    with lock:
        num = num + 1


def withdraw():
    global num
    for i in range(10000000):
        #获取锁
        lock.acquire()
        num = num - 1
        #释放锁
        lock.release()

if __name__ == '__main__':
    #创建两个子线程
    t1 = threading.Thread(target=deposit)
    t2 = threading.Thread(target=withdraw)

    #启动线程
    t1.start()
    t2.start()

    #join方法：让子线程阻塞主线程，
    #主线程会等待使用了join方法的子线程结束后再往下进行
    t1.join()
    t2.join()

    print(num)  #结果会是0
```

# 多线程通信 Queue
```python
from queue import Queue
import threading
import time

def product(q):
    for i in range(3):
        kind = ('猪肉','白菜','豆沙')
        print(threading.current_thread( ).name,"包子生产者开始生产包子...")
        time.sleep(1)
        #往队列里放东西
        q.put(kind[i % 3])
        print(threading.current_thread( ).name,"包子生产者的包子做完了!")

def consumer(q):
    while True:
        print(threading.current_thread( ).name,"消费者准备吃包子")
        time.sleep(1)
        #如果队列为空，则阻塞，直到有东西可以拿
        t = q.get()
        print(f'消费者吃了一个{t}包子! ')
            

if __name__ == '__main__':
    #一个消息队列，指定只能装一个
    q=Queue(maxsize=1)
    
    #启动两个生产者线程
    threading.Thread(target=product, args=(q, )).start()
    threading.Thread(target=product,args=(q, )).start()

    #启动消费者线程
    threading.Thread(target=consumer,args=(q, )).start()
```


- 多线程优点:效率比较高，不会耗费大量资源。
- 多线程缺点:稳定性较差，一个崩溃后会影响整个进程。

- 多线程适用场景:适合IO密集型任务，比如文件读取以及爬虫等操作。
